Observations and Conclusions
Question 1:
The light sensor localization is by far a more accurate method than ultrasonic localization. This makes sense because of the simplicity of the method. There is little room for error with lightsensor localization if it is performed correctly (explained in the answer to question two below). On the other hand the ultrasonic sensor is very susceptible to noise and the position at which the robot is placed can affect its ability to localize. For example, we noticed when the robot was placed very close to the wall near the corner the ultrasonic sensor would read values that were higher than they were actually were. This could be caused by a number of factors such as reflection of sound waves off the wall perpendicular to the wall the robot is facing (and other types of error caused by reflection), detection of other ultrasonic waves in the environment that might be concentrated in the corners of the field when they reflect off the two perpendicular walls, or simply a fault in the ultrasonic sensor’s design. To address this non-ideal behavior, we experimented with the static attribute variable for the distance of the sensor from the center of robot. Humidity is also a factor because it affects the speed sound waves travel through the air. This might not introduce a significant error on most days, but could explain variation in the effectiveness of ultrasonic localization over different days, and is something to consider. A calibration of the sensor before the program runs by measuring a known distance could also be a solution. Similarly, the light sensor readings are affected by the level of ambient lighting in the room, and this can similarly be corrected by doing a calibration before the robot runs. In this lab, the lighting seemed to be constant, and we did not have a problem with this.
Question 2:
The contrast between the black lines and tan/yellow board allows the light sensor to detect a sudden change from light to dark as the robot rotates over the line. The lines are thick enough to easily detect, but narrow enough that when the robot reads dark it can estimate its position with relation to the lines along the given axis to within a few millimeters. The fact that the lines are straight, perpendicular, and equally spaced makes it very easy for the robot to determine its position within a square with accuracy. However, this knowledge is useless if the robot does not know which square it is in, and that is the purpose of the ultrasonic localization. Using only the light sensor it is impossible for the robot to determine which square it is in because it does not know where the edges of the field are. However, once the ultrasonic sensor get the robot within a known square, the light sensor can determine the robot’s position to within half a centimeter. Accuracy could probably be improved to a millimeter by introducing optimizations such as detecting rising and falling edges and using the average to get the center of the line. The ultrasonic sensor is less effective and only used for approximating the robots position because of noise, which drastically reduces its effectiveness. Additionally, the differing sound wave absorption properties of different materials, such as the wooden walls, and the variation in absorption properties within a single material introduce more error.
Question 3:
If the robot is placed anywhere in the field and needs to localize using only the ultrasonic sensor it first needs to locate a wall. The idea would be to get the robot to drive to a corner because then it has an x and y value corresponding to the distance from each wall. Since lines are spaced at about 30cm, if the robot gets itself to a corner where its minimum distances from each wall are 15cm, then it will be in the center of that tile. To do this it should spin 360 degrees and find the smallest value. If the robot is placed in the center the field it is possible that it will be too far from all the walls and read 255. Of course noise will also need to be filtered out. If the robot rotates full circle and does not detect a line it should drive straight until it does and then proceed. When it reads a wall after moving, or spins full circle and establishes a minimum value, it should move either toward or away from the object to establish a distance reading of 15. Because of inaccuracies in the ultrasonic sensor, it might be at an angle to the wall so it should establish the minimum and readjust its distance to 15. This will improve accuracy. Then it should check 90 degrees to its left and right and drive to within 15 of that wall. Again if no wall is found then just default to left or right. Now the robot knows it is in a corner, and can localize using the method from this lab. However, if no additional information is known, i.e. x, y, and theta are all unknown when the robot is placed, it is impossible to determine which corner the robot is in. Thus the approximate heading of the robot needs to be known or some other piece of information needs to be given.
The problem of detecting a minimum with the ultrasonic sensor is complicated by noise. If you have a smooth curve then finding a local minimum is simply a matter of finding the turning point by looking for a decrease and then and increase in the distance values. To find an absolute minimum, you would rotate full circle and use the smallest value. However, interference can introduce values ranging from 0 to 254, in addition to the 255 value which does not indicate a distance. For the purpose of finding a minimum these dips in the value should not be considered. To do this a filter is applied which smooths the curve by taking averages and completely omitting a sudden drop followed by a return to normal values. While this improves accuracy greatly it is hard to create a sensor that can consider obstacles that would create a sudden drop or spike in distance values and also filter extraneous values cause by noise. A good solution to this is pausing or slowing down to increase the accuracy of the sensor. This allows you to get more readings and thus improves the filter.
